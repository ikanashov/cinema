# Принцип работы ETL

Общее ограничение выборку делаем по 200 записей (должно задоваться через конфиг, ETL_SIZE_LIMIT ). Не забываем везде немного спать, чтобы не грузить сервис.

1. Принцип работы следующий, выбираем все последовательно из всех таблиц новые записи, на основании этих записей формируем ID изменишихся фильмов.
   1. Отдельная корутина выбирает изменишиеся фильмы.
   2. Если изменения в таблицы участников фильмов, то выбираем все связанные фильмы. (два разных задачи)
   3. Если изменения в таблицы жанры, выбираем все связанные фильмы. (два разных, задачи)
   4. Если изменения в таблице типфильма, выбираем все связанные фильмы. (две разных задачи, или одна наверное тут нет промежуточных таблиц)
   5. Еще продумать(но потом), как выбирать удаленные фильмы (наверное надо джангу заставить при удалении фильма посылать сигнал).
В итоге первого этапа, у нас должно образоваться ИДшники измененых фильмов. Как только их набролось 200, переходим на следующий этап, хотя теоретически можно сделать отдельный скрипт, который будет складывать ИДшники требующие обновления. 
2. Далее большим запросом, выбираем все изменишиеся фильмы с теми данными которые нам необходимы для загрузки в ES.
   1. Загружаем по ETL_bulk_size записей, запрос должен сразу возвращать данные которые нужны в Еластик.
В итоге должен получится список словарей (или словарь, словарей) который будет передаваться в следующий этап.
3. Далее загружаем все в ES.
   1. Грузим данные пачкой в ES, если произошла ошибка, то делаем это снова, если все ок, то помечаем загруженные ИД, как переданные, и грузим их в таблицу история, из таблицы ожидающих удаляем.

Принцип хранения состояний в редис (через конфиг вводим префикс для всех ключей REDIS_PREFIX, и добавляем его ко всем ключам). В редис по каждой из таблиц, записываем время последней выбранной записи. В редис пишем все состояния, кто читает кто пишет, кто что делает. Таблицу ожидающих ораганизовать как очередь, первый пришел первый уйдешь.
Очередь в редисе LPUSH, RPOP


Между частями (2 и 3) передаем данные через датаклас.

Отдельный метод делающий запрос в постргес

Запросы вынести в отдельный класс (или константами)

pydantic, backoff, logging

Отдельный класс для редиса.
Отдельный класс для формирования очереди ИД.
Отдельный класс для загрузки данных ИД из PG в ES.
Отдельный класс для валидации конфига.

Предусмотреть, чтобы в один момент времени только одна из корутин могла читать данные из PG. Должно быть видно кто занял, и как давно. Другой читальщик должен выводить раз в какое-то время эту информацию в лог.

+Первым пишем, все СКУЛЬ запросы.
Вторым пишет редис.
Третьим пише выборку данных для ES
+Четвертым пишем загрузка данных в ES
Пятым валидируем конфиг.
Потом добавляем backoff.
